.. endpoints:

General Behaviour
=================

The API will generally return a list of available endpoints if the request refers to a non-supported URL, with a ``200`` code.

The API is to generally return a ``500`` error in case there was an error in the handling of the code
(for example, on validation of one of the input to provide to a workflow, or a non-supported property), along with a
json message containing only a ``message`` key with the error encountered in Python.

On successful request, the app returns a ``200`` status and a general list of properties:

- a ``data`` key containing the retrieved data
- a general summary of the request: the url, url_root, and query string, the relative path of the endpoint, the method used to access the
  page (GET, POST), and the ``ID`` of the node database accessed if relevant

Available endpoints
=====================

The app runs at the the address ``HOSTNAME:PORT/PREFIX/ENDPOINT``, where ``HOST`` and ``PORT`` are property that can be set
by the app options.

The prefix has been modified from the rest api ``/api/v4/`` to  ``/intersect/v4`` to remind of where
it comes from; this can be changed in the configuration options if necessary.

In the following I'm going to assume a base URL as ``127.0.0.1:5000/intersect/v4``.

Every URL build upon this base URL, if it does not correspond to a used endpoint should redirect
to a list of the accepted endpoints. This is a list of the AiiDA REST plus the ones we have defined.

For an explanation of the AiiDA endpoint you can check the
`AiiDA REST api page <https://aiida.readthedocs.io/projects/aiida-core/en/latest/restapi/>`_.
The additional ones are explained below.

Any of this endpoints can be accessed via a browser for ``GET`` method, but will need an extension to deal with a POST request.
In the peoceeding I assume a request to be done by terminal one unix with the `httpie utility <https://httpie.org/>`_, i.e ::

    http 127.0.0.1:5000/intersect/v4/nodes/

accesses the ``127.0.0.1:5000/intersect/v4/nodes/`` with a ``GET`` request, while ::

    http 127.0.0.1:5000/intersect/v4/submit/ < filename

forward the content of the  ``filename`` file as a ``POST`` request.
Other resources, like curl or chrome extensions can be used.



properties
++++++++++

The ``ginestra/properties`` endpoint lists all the available property that can be request for a calculation, and returned as a list.

Example::

    http 127.0.0.1:5000/intersect/v4/properties

Expected response (http response 200)

.. code-block:: json

    {
        "data": {
            "band_gap.pw": "post.BandGap",
            "band_structure.pw": "quantumespresso.pw.band_structure",
            "relax.pw": "quantumespresso.pw.relax",
            "structure.cod": "post.CODImport"
        },
        "id": null,
        "method": "GET",
        "path": "/intersect/v4/ginestra/properties",
        "query_string": "",
        "request_content": null,
        "resource_type": "Information about the properties available for calculation",
        "url": "http://127.0.0.1:5000/intersect/v4/ginestra/properties",
        "url_root": "http://127.0.0.1:5000/"

Each key of the ``data`` section represents a property that can be used as an input. Note that it is not necessary to have
a map 1:1 between properties and workflows, as a workflow can be used for more than one.

Generally, I think it is useful to have a name followed
by a code identifier, if we want to make immediately obvious that we want to calculate a property with a specific code/method.

submit
+++++++

This is the endpoint related to the submission of a workflow. Since it requires an input to work, it is necessary to use
a POST method to provide this information to AiiDA.

A json file for now isjust a dictionary with two entries:
- *calculation*: the mapped keyword to identify the workflow to run through its property name;
- *input*: the dictionary input for the workflow

The inputs of a workflow represents dictionary classes, represented with the standard python class name, but with an uppercase
initial, in order for the workflow to generate links between the stored properties in the database.

To avoid having to specify for each key entry what kind of classes it is expected to be and to make it more easy to read,
the app will try to guess the type from the type of the workflow input; so if an input expect a ``code`` instance, we can pass a ``pk``, ``uuid``
or ``label`` to uniquely load it from the AiiDA database; if a node is of ``Float`` type it will convert the float provided to the equivalent database type.

In order to have flexibility, if we want to pass a ``Node`` directly (instead of a value) we need to pass a dictionary where the key is
called ``LOADNODE``; the input will be generated by passing the content of the node ID provided.

For example, imagine the following case:

.. code-block:: json

     {
     "calculation": "property.siesta",
     "input": {
       "structure": 2547,
       "code": 667,
       "string_entry": "my string value"
     }
 }

The ``string_entry`` value will be converted to ``Str(str="my string value")`` (the AiiDA database string node), while

.. code-block:: json

     {
     "calculation": "property.siesta",
     "input": {
       "structure": 2547,
       "code": 667,
       "string_entry": {
          "LOADNODE": 3546
       }
     }
 }

will load the content of the node 3546 and use if as input.
If it does not crrespond to a Str Node, an exception will be raised.

The result of this call to the endpoint ::

    http 127.0.0.1:5000/intersect/v4/ginestra/submit < aiida_post_dir/examples/search_hfo2.json

where the ``search_hfo2.json`` file is taken from the examples folder, should return the following response (html code 200)

.. code-block:: json

    {
        "data": {
            "error": "",
            "error_info": "",
            "workflow": {
                "attributes": {
                    "exit_message": null,
                    "exit_status": null,
                    "process_class": null,
                    "process_label": "CODImportWorkChain",
                    "process_state": "created",
                    "stepper_state_info": null,
                    "version": {
                        "core": "1.0.0",
                        "plugin": "0.1a1"
                    }
                },
                "ctime": "Tue, 26 Nov 2019 14:58:48 GMT",
                "uuid": "bf80763c-aea3-48e5-a5e9-c1649caf9fca"
            }
        },
        "id": null,
        "method": "POST",
        "path": "/intersect/v4/ginestra/submit/",
        "query_string": "",
        "request_content": {
            "data":{
              "calculation": "structure.cod",
              "input": {
                "codquery": {
                    "formula": "Hf O2",
                    "schemical_name": "wurtzite",
                    "some_data": 32
                },
                "metadata": {
                    "label": "somelabel"
                },
                "strictcheck": false
              },
            "node": "6c13fa84-aea4-44d8-a202-93d8b0e34f24"

        },
        "resource_type": "submission of workflows",
        "url": "http://127.0.0.1:5000/intersect/v4/ginestra/submit/",
        "url_root": "http://127.0.0.1:5000/"
    }

where the ``data`` key contains the ``uuid`` entry that identify the workflow uuid that can be queried to the database, and
other attributes of the created process.

The process has at this point just been created: unless extremely quick its attributes will not be populated;
teh exit_message and exit_code would provide a clue that something failed, while the other attributes provides hints
regarding the python class and the version of AiiDA/plugin used for such calculation.
The response also include a copy of the provided json file under the ``request_content`` key, and its node uuid in case this
information is needed for future queries.

In case of failure during the creation of the workflow the response will simply be be an error message with some more indication of the
problem, but no ``data`` key or other attributes.


workflow_inputs/<property>
+++++++++++++++++++++++++++

The required input for a workflow can be obtained either by exploring the relevant AiiDA class , or through
the ``verdi plugin aiida.workflow <wf>`` command, that will provide a list of inputs, outputs and error code for
the workflow <wf>.

This has been ported to the endpoint workflow_inputs.
The idea is that we can query the database for a specific property in the MAPPING_PROPERTY list to obtain a list of the
input ports of the workflow, their type, if their required, and if they have a default. A helper string provides a descritpion
of what the input is for, if who wrote the workflow provided it.

One important thing to remember is that every workflow comes with optional inputs called ``metadata`` that are not stored in the database,
and therefore are simple python classes. Another impotant point is that a nested workflow might need inputs for the workflow it calls as
well, and those are listed and can be filled as sub-dictionaries of the main input dictionary.

For example, ::

    http 127.0.0.1:5000/intersect/v4/ginestra/workflow_inputs/band_structure.pw

should result in the response (**note that you need to have the aiida-quantum espresso plugin installed**)

.. code-block:: json

    {
        "data": {
            "workflow_input_schema": {
                "code": {
                    "default": "None",
                    "has_default": false,
                    "help_string": "The `pw.x` code to use for the `PwCalculations`.",
                    "is_required": true,
                    "valid_type": "<class 'aiida.orm.nodes.data.code.Code'>"
                },
                "metadata": {
                    "call_link_label": {
                        "default": "CALL",
                        "has_default": true,
                        "help_string": "The label to use for the `CALL` link if the process is called by another process.",
                        "is_required": false,
                        "valid_type": "(<class 'str'>,)"
                    },
                    "description": {
                        "default": "None",
                        "has_default": false,
                        "help_string": "Description to set on the process node.",
                        "is_required": false,
                        "valid_type": "(<class 'str'>,)"
                    },
                    "label": {
                        "default": "None",
                        "has_default": false,
                        "help_string": "Label to set on the process node.",
                        "is_required": false,
                        "valid_type": "(<class 'str'>,)"
                    },
                    "store_provenance": {
                        "default": "True",
                        "has_default": true,
                        "help_string": "If set to `False` provenance will not be stored in the database.",
                        "is_required": false,
                        "valid_type": "<class 'bool'>"
                    }
                },
                "options": {
                    "default": "None",
                    "has_default": false,
                    "help_string": "Optional `options` to use for the `PwCalculations`.",
                    "is_required": false,
                    "valid_type": "<class 'aiida.orm.nodes.data.dict.Dict'>"
                },
                "protocol": {
                    "default": "uuid: 467aa69c-646c-448f-aa4b-84cc3c5defdb (unstored)",
                    "has_default": true,
                    "help_string": "The protocol to use for the workchain.",
                    "is_required": false,
                    "valid_type": "<class 'aiida.orm.nodes.data.dict.Dict'>"
                },
                "structure": {
                    "default": "None",
                    "has_default": false,
                    "help_string": "The input structure.",
                    "is_required": true,
                    "valid_type": "<class 'aiida.orm.nodes.data.structure.StructureData'>"
                }
            }
        },
        "id": null,
        "method": "GET",
        "path": "/intersect/v4/ginestra/workflow_inputs/band_structure.pw",
        "query_string": "",
        "resource_type": "return workflow input schema",
        "url": "http://127.0.0.1:5000/intersect/v4/ginestra/workflow_inputs/band_structure.pw",
        "url_root": "http://127.0.0.1:5000/"

